1. How does Java’s multithreading capability enable you to write more efficient programs?

It allows a program to execute multiple actions in parallel, using CPU time which would otherwise be idle.

2. Multithreading is supported by the _________ class and the ________ interface.

Thread and Runnable

3. When creating a runnable object, why might you want to extend Thread rather than implement Runnable?

You would extend Thread if you wanted to override any of its methods other than run()

4. Show how to use join( ) to wait for a thread object called MyThrd to end.

MyThrd.join();

5. Show how to set a thread called MyThrd to three levels above normal priority.

MyThrd.setPriority( Thread.NORM_PRIORITY + 3 );

6. What is the effect of adding the synchronized keyword to a method?

It allows only one thread at a time to use the method.

7. The wait( ) and notify( ) methods are used to perform _______________________.

Interthread communication

8. Change the TickTock class so that it actually keeps time. That is, have each tick take one half second, and each tock take one half second. Thus, each tick-tock will take one second. (Don’t worry about the time it takes to switch tasks, etc.)

See ThreadCom.java

9. Why can’t you use suspend( ), resume( ), and stop( ) for new programs?

They were deprecated in Java 2 due to the possibility of highly undesireable behaviour.

10. What method defined by Thread obtains the name of a thread?

Thread.getName();

11. What does isAlive( ) return?

Boolean - true if the target thread is still running; false otherwise

12. On your own, try adding synchronization to the Queue class developed in previous chapters so that it is safe for multithreaded use.

